---
editor_options:
  chunk_output_type: inline
title: "Routinely Randomize Potential Sources of Measurement Reactivity to Estimate and Adjust for Biases in Subjective Reports"
header-includes:
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
- \floatplacement{figure}{H}
output: 
  pdf_document: 
    latex_engine: xelatex
    number_sections: yes
    toc: yes
    toc_depth: 3
---


todo:
- make figures and tables for multilevel model (take code from 2_)
- frame other models as robustness checks
  - complete first week
  - 

```{r}
options(stringsAsFactors = FALSE)
#' show two significant digits tops
options(digits = 2)
#' tend not to show scientific notation, because we're just psychologists
options(scipen = 7)
#' make output a bit wider
options(width = 110)
#' set a seed to make analyses depending on random number generation reproducible
set.seed(1710) # if you use your significant other's birthday make sure you stay together for the sake of reproducibility


#' ## Load packages
#' generate the site
library(rmarkdown)
#' set options for chunks
library(knitr)
#' my formr utility package to generate e.g. the bibliography
library(formr)
#' pretty-printed output
library(pander)
#' tidyverse date times
library(lubridate)
#' tidyverse strings
library(stringr)
#' extractor functions for models
library(broom)
#' grammar of graphics plots
library(ggplot2)
#' svg graphs
# library(svglite);
library(feather)
library(ggthemes)
library(codebook)
library(kableExtra)
library(Cairo)
library(paletteer)

#' tidyverse: has a lot of naming conflicts, so always load last
library(tidyverse)
opts_chunk$set(warning = F, message = F, error = TRUE, fig.width = 13, fig.height = 10)
library(broom.mixed)
library(tidylog)
options(width = 4000)
theme_set(theme_classic() + theme_pander(base_size = 18))
```


```{r}
key <- keyring::key_get_raw("encrypt_data_routinely_randomise")
class(key) <- c("aes", "raw")
key <- cyphr::key_openssl(key)
s3_daily_id_answered <- cyphr::decrypt(readRDS("s3_daily_id_answered.rds"), key)
diary <- cyphr::decrypt(readRDS("diary.rds"), key)

s3_daily_id_answered <-  rio::import("../routine_and_sex/data/s3_daily_id_answered.feather")
```

## Additional descriptive statistics

```{r fig.cap="Weekday distribution on diary starting day. We see that women were more likely to start the study on a week day."}
ggplot(diary %>% drop_na(created_diary) %>% filter(day_number == 0), aes(weekday)) + 
  geom_bar() +
  ggrepel::geom_label_repel(aes(x = weekday, y = stat(count), label = stat(count)), 
                            stat = "count", force = 0)
```

```{r fig.cap="Distributions of items", fig.height=5, fig.width=5}
first_page %>% ggplot(aes(answer)) + 
  geom_bar() + 
  facet_wrap(~ label_english, ncol = 2, scales = "free_y") +
  scale_x_continuous("Response", breaks = 0:4, labels = c("[0] less\nthan\nusual", 1, 2, 3, "[4] more\nthan\nusual")) +
  ggrepel::geom_label_repel(aes(x = answer, y = stat(count), label = stat(count)), 
                            stat = "count", force = 0, size = 2)
```

```{r fig.cap="A quick verification that fluctuation in whether a question is asked is as random as intended over time. The Y axes include the global mean ± 1 global standard deviation for each item.", fig.width=5,fig.height=6}
first_page %>% 
  group_by(day_number) %>% 
  mutate(n_days = n_distinct(session)) %>% 
  group_by(label_english, day_number) %>% 
  summarise(n = n()/first(n_days)) %>% 
ggplot(., aes(day_number, n)) + 
  geom_line() +
  scale_y_continuous("Question asked") +
  scale_x_continuous("Day number") +
  facet_wrap(~ label_english, ncol = 2)
```

```{r fig.cap="No strong time trends in the responses. Y axis range is overall mean ±1SD.", fig.width=5,fig.height=6}
first_page %>% 
  ggplot(., aes(day_number, answer)) + 
  geom_blank(aes(y = item_mean, ymin = item_mean - item_sd, ymax = item_mean + item_sd)) +
  geom_hline(aes(yintercept = item_mean), linetype = 'dashed') + 
  geom_pointrange(position = position_dodge(width = 0.2), stat='summary', fun.data = 'mean_se') + 
  geom_line(position = position_dodge(width = 0.2), stat='summary', fun.data = 'mean_se') +
  scale_y_continuous("Response") +
  facet_wrap(~ label_english, ncol = 2, scales = "free_y") +
  scale_x_continuous("Day number") +
  ggtitle("Responses over time")
```


## Initial elevation bias

```{r fig.cap="Figure 2, including combinations with fewer than 20 observations."}
first_page %>% 
  filter(day_number < 7) %>% 
  group_by(item_name) %>% 
  mutate(group_mean = mean(answer, na.rm = TRUE)) %>%
  # group_by(item_name, day_number, first_day_of_item_factor) %>%
  # filter(n_nonmissing(answer) > 20) %>%
  ggplot(., aes(day_number, answer, colour = first_day_of_item_factor)) + 
  geom_blank(aes(y = item_mean, ymin = item_mean - item_sd, ymax = item_mean + item_sd)) +
  geom_hline(aes(yintercept = group_mean, group = label), color = "gray", linetype = 'dashed') +
  geom_pointrange(position = position_dodge(width = 0.2), stat = 'summary', fun.data = 'mean_se') + 
  geom_line(position = position_dodge(width = 0.4), stat = 'summary', fun.data = 'mean_se') + 
  scale_color_colorblind("First day the\nitem was shown") +
  scale_y_continuous("Response") +
  facet_wrap(~ label_english, scales = "free_y") + 
  scale_x_continuous("Day number", breaks = 0:10)
```


```{r fig.cap="An alternative, more focused visualisation of initial elevation bias. Are responses elevated when shown for the first time, even if it is not the first day of the diary? The dashed line shows the overall mean for the item. Standard errors cannot be seen, because they are so narrow (and ignore the multilevel structure of the data."}
first_page %>% 
  group_by(item_name) %>% 
  mutate(group_mean = mean(answer, na.rm = TRUE),
         day = if_else(first_day_of_item_shown, if_else(day_number == 0, 
                       "first item, \nfirst day", "first item, \nlater day"), "later day")) %>%
  group_by(item_name, day) %>% 
  filter(n_nonmissing(answer) > 20) %>% 
  ggplot(., aes(day, answer)) + 
  geom_blank(aes(y = item_mean, ymin = item_mean - item_sd, ymax = item_mean + item_sd)) +
  geom_hline(aes(yintercept = group_mean, group = label), color = "gray", linetype = 'dashed') +
  geom_pointrange(position = position_dodge(width = 0.2), stat = 'summary', fun.data = 'mean_se') + 
  scale_y_continuous("Response") +
  facet_wrap(~ label_english, scales = "free_y")
```



```{r fig.cap="A response bias to a Likert scale may not only affect the mean response, but also the dispersion or the propensity to choose the middle or extreme categories. Such biases would balance out and not show up in the mean response. We therefore compute the relative frequency of certain responses for first days and later days. Days on which the item is first shown have very similar response distributions as later days."}
first_page %>% 
  filter(day_number < 11) %>% 
  mutate(day = if_else(first_day_of_item_shown, if_else(day_number == 0, 
                       "first item, \nfirst day", "first item, \nlater day"), "later day")) %>%
  group_by(label_english, item_name, day) %>% 
  mutate(group_n = n_nonmissing(answer)) %>% 
  group_by(label_english, item_name, day, answer) %>% 
  summarise(rel_freq = n_nonmissing(answer)/first(group_n)) %>% 
  ggplot(., aes(answer, y = rel_freq, colour = day)) + 
  geom_line(position = position_dodge(width = 0.2)) + 
  scale_y_continuous("Relative frequency") +
  scale_x_continuous("Response", breaks = 0:4, labels = c("[0] less\nthan\nusual", 1, 2, 3, "[4] more\nthan\nusual")) +
  facet_wrap(~ label_english, scales = "free_y")
```


```{r fig.cap="We can additionally examine whether responses slow down when items are first shown. We only examine the response time relative to the answer to the previous item here. This means the first item is excluded from consideration. We do this, because responses relative to the time the page loaded are strongly biased upwards through participants who clicked the link and did something else until the page loaded, or participants who first familiarise themselves with all items. Responses to the first item take almost 8000ms, much longer than responses to later items. The line shows the 10% trimmed means, the points show means plus standard errors. We excluded responses that were made out of order (negative response times relative to the previous item), and responses that took longer than 30 seconds."}
first_page %>% 
  filter(day_number < 11) %>% 
  filter(response_time_since_previous < 1*30*1000, response_time_since_previous > 0) %>% 
  group_by(item_name) %>% 
  mutate(group_mean = mean(response_time_since_previous, na.rm = TRUE),
         day = if_else(first_day_of_item_shown, if_else(day_number == 0, 
                       "first item, \nfirst day", "first item, \nlater day"), "later day")) %>%
  group_by(item_name, day) %>% 
  filter(n_nonmissing(response_time_since_previous) > 20) %>% 
  ggplot(., aes(day, response_time_since_previous/1000)) + 
  geom_hline(aes(yintercept = group_mean/1000, group = label), color = "gray", linetype = 'dashed') +
  geom_pointrange(position = position_dodge(width = 0.2), stat = 'summary', fun.data = 'mean_se') + 
  scale_y_continuous("Response time relative to previous item (in s)") +
  facet_wrap(~ label_english, scales = "free_y")
```


```{r fig.cap="We can also examine response times as in Figure 2, but switching to the time series view somewhat clutters the display. Limited to combinations with at least 20 responses."}
first_page %>% 
  filter(day_number < 11, response_time_since_previous < 30*1000, response_time_since_previous > 0) %>% 
  group_by(item_name) %>% 
  mutate(group_mean = mean(answer, na.rm = TRUE)) %>% 
  group_by(item_name, day_number, first_day_of_item_factor) %>% 
  filter(n_nonmissing(answer) > 20) %>% 
  ggplot(., aes(day_number, response_time_since_previous/1000, colour = first_day_of_item_factor)) + 
  # geom_pointrange(alpha = 0.3, position = position_dodge(width = 0.2), stat ='summary', fun.data = 'mean_se') + 
  geom_line(position = position_dodge(width = 0.4), stat ='summary', fun.y = function(x) { mean(x, na.rm =T, trim = 0.1) }) +
  scale_color_colorblind("First day the\nitem was shown") +
  scale_x_continuous("Day number", breaks = 0:10) +
  scale_y_continuous("Response time (in s) since previous item") +
  facet_wrap(~ label_english)
```


### Time series by first day item shown (complete 1st week)


```{r fig.cap="Here, only with those who didn't miss a day in the first week (ruling out selective dropout as an explanation). Patterns seem unchanged."}
first_page %>% 
  filter(day_number < 7, didntmissfirstweek == TRUE) %>% 
  group_by(item_name) %>% 
  mutate(group_mean = mean(answer, na.rm = TRUE)) %>% 
  group_by(item_name, day_number, first_day_of_item_factor) %>% 
  filter(n_nonmissing(answer) > 20) %>% 
  ggplot(., aes(day_number, answer, colour = first_day_of_item_factor)) + 
  geom_blank(aes(y = item_mean, ymin = item_mean - item_sd, ymax = item_mean + item_sd)) +
  geom_hline(aes(yintercept = group_mean, group = label), color = "gray", linetype = 'dashed') +
  geom_pointrange(position = position_dodge(width = 0.2), stat = 'summary', fun.data = 'mean_se') + 
  geom_line(position = position_dodge(width = 0.4), stat = 'summary', fun.data = 'mean_se') + 
  scale_color_colorblind("First day the\nitem was shown") +
  scale_y_continuous("Response") +
  facet_wrap(~ label_english, scales = "free_y") + 
  scale_x_continuous("Day number", breaks = 0:10)
```

## Item order

```{r fig.cap="As above, we can not only examine the mean but also the response distribution according to item order."}
first_page %>% 
  group_by(label_english, item_name, display_order) %>% 
  mutate(group_n = n_nonmissing(answer)) %>% 
  group_by(label_english, item_name, display_order, answer) %>% 
  summarise(rel_freq = n_nonmissing(answer)/first(group_n)) %>% 
  ggplot(., aes(answer, y = rel_freq, colour = display_order, group = display_order)) + 
  geom_line(position = position_dodge(width = 0.2)) + 
  scale_color_continuous("Item order") +
  scale_y_continuous("Relative frequency") +
  scale_x_continuous("Response", breaks = 0:4, labels = c("[0] less\nthan\nusual", 1, 2, 3, "[4] more\nthan\nusual")) +
  facet_wrap(~ label_english, scales = "free_y")
```


```{r fig.cap="Again, we can also examine the response time to each item according to item order."}
first_page %>% filter(response_time_since_previous < 1*30*1000, response_time_since_previous > 0, display_order > 1) %>% 
  ggplot(., aes(display_order, response_time_since_previous/1000)) + 
  geom_pointrange(alpha = 0.3, position = position_dodge(width = 0.2), stat ='summary', fun.data = 'mean_se') + 
  geom_line(position = position_dodge(width = 0.4), stat ='summary', fun.y = function(x) { mean(x, na.rm =T, trim = 0.1) }) +
  scale_y_continuous("Response time (in s) since previous item") +
  facet_wrap(~ label_english, scales = 'free_y')
```


## Number of items shown
As mentioned above, the number of items shown is also a randomised variable.
It is in turn confounded with item order, because items shown on a page with more items
are likely to have a later item order. Most importantly, when only one item is shown, item order
is necessarily `1`.

```{r fig.cap="Response means according to the number of items shown. The Y axis scale is displayed from each item’s mean ± 1 SD; values ranged from 0 to 4. The standard errors for the means do not account for the person-level structure of the data."}
first_page %>% 
  ggplot(., aes(number_of_items_shown, answer)) + 
  geom_blank(aes(y = item_mean, ymin = item_mean - item_sd, ymax = item_mean + item_sd)) +
  geom_pointrange(position = position_dodge(width = 0.2), stat ='summary', fun.data = 'mean_se') + 
  # geom_line(position = position_dodge(width = 0.4), stat ='summary', fun.data = 'median_hilow') + 
  scale_y_continuous("Response") +
  facet_wrap(~ label_english, scales = 'free_y')
```


```{r  fig.cap="Again, we can also examine the response time to each item according to number of items shown."}
first_page %>% filter(response_time_since_previous < 1*30*1000, response_time_since_previous > 0, display_order > 1) %>% 
  ggplot(., aes(number_of_items_shown, response_time_since_previous/1000)) + 
  geom_pointrange(alpha = 0.3, position = position_dodge(width = 0.2), stat ='summary', fun.data = 'mean_se') + 
  geom_line(position = position_dodge(width = 0.4), stat ='summary', fun.y = function(x) { mean(x, na.rm =T, trim = 0.1) }) +
  scale_y_continuous("Response time (in s) since previous item") +
  facet_wrap(~ label_english, scales = 'free_y')
```

## Last item
It is not possible to infer whether the item content would bias the next response
(i.e., a reminder of stress truly lowers mood) or whether these are the function
of participants minimising "mousework" (i.e., after responding 4 to one item,
it is slightly less effort to answer 4 for the next item too than to choose
a different response, and certain items elicit higher mean responses).

We can exclude people who gave the same response to items as a robustness check.
Of course, giving the same response to all items is not that unlikely when only two
items were asked, and it is entirely possible for straightline response to be 
legitimate (even if they exceed the nominal probability expected if responses were
independent, they may be more frequent on very quotidian days in a way that is 
difficult to model).

```{r}
first_page %>% 
  group_by(session, unit_session_id) %>% 
  filter(sd(answer, na.rm = TRUE) > 0) %>% 
  ggplot(., aes(last_item, answer)) + 
  geom_blank(aes(y = item_mean, ymin = item_mean - item_sd, ymax = item_mean + item_sd)) +
  geom_pointrange(position = position_dodge(width = 0.2), stat ='summary', fun.data = 'mean_se') + 
  # geom_line(position = position_dodge(width = 0.4), stat ='summary', fun.data = 'median_hilow') + 
  scale_y_continuous("Response") +
  coord_flip() +
  facet_wrap(~ label_english, scales = 'free_x')
```


```{r fig.cap="As above, we can not only examine the mean but also the relative frequencies of  each response.", fig.width=10}
first_page %>% 
  group_by(label_english, item_name, last_item) %>% 
  mutate(group_n = n_nonmissing(answer)) %>% 
  group_by(label_english, item_name, last_item, answer) %>% 
  summarise(rel_freq = n_nonmissing(answer)/first(group_n)) %>% 
  ggplot(., aes(answer, y = rel_freq, colour = last_item)) + 
  geom_line(position = position_dodge(width = 0.2)) + 
  scale_color_colorblind("Last item") +
  scale_y_continuous("Relative frequency") +
  scale_x_continuous("Response", breaks = 0:4, labels = c("[0] less\nthan\nusual", 1, 2, 3, "[4] more\nthan\nusual")) +
  facet_wrap(~ label_english, scales = "free_y")
```


## Multilevel analysis 
We have investigated each randomised variable in turn, but we also noted that
item order and number of items shown are confounded with one another. In addition,
the first day an item is shown is likely to be an earlier day of the diary, where we might
expect to see selection bias, and it's more likely to be a weekday, not a weekend day. 
Further, we varied the instructions in the diary depending on how long ago the last diary was answered. 
We instructed participants to refer to the time period since their last diary entry, if that had happened within the last 24 hours, or to the last 24 hours, if the last diary entry was longer ago (and if it was their first diary entry).

A natural way to disentangle these confounds is to simultaneously enter them into a 
regression. We fit one multilevel regression per item in lme4.


```{r}
library(lme4)
library(lmerTest)
library(purrr)
```

### Initial elevation bias
Here, we are adjusting for day number (0 to 7+, larger numbers are binned because covariates can no longer be isolated) and the time period referred to. We also enter a random effect for which day the item was first shown, and the participant.

```{r}
initial_elevation_bias <- first_page %>% 
  split(.$item_name) %>%
  map(~ lmer(answer ~ day_number_factor + first_day_of_item_shown + refer_time_period + (1 | session), data = .)) %>% 
  map(~ tidy(., conf.int = TRUE)) %>% 
  bind_rows(.id = "response")
```

```{r}
initial_elevation_bias %>% 
  select(response, effect, group, term, estimate, conf.low, conf.high, std.error, p.value) %>% 
    knitr::kable(format = "latex", booktabs = TRUE, caption = "Multilevel regression models to test for initial elevation bias") %>%
  footnote("On average, BASE-II respondents endorsed more options in the social/experiential reference frame question.", threeparttable = TRUE) %>% 
  kable_styling(latex_options = "hold_position")
```

```{r layout='l-body-outset'}
initial_elevation_bias %>% 
  ggplot(aes(x = response, y = estimate, ymin = conf.low, ymax = conf.high)) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  geom_pointrange() +
  coord_flip()
```

### Item order and number

```{r}
item_order_bias <- first_page %>% 
  split(.$item_name) %>%
  map(~ lmer(answer ~ day_number_factor + display_order  + number_of_items_shown + refer_time_period + (1 | session), data = .)) %>% 
  map(~ tidy(., conf.int = TRUE)) %>% 
  bind_rows(.id = "response") %>% 
  filter(term %in% c("number_of_items_shown", "display_order"))
```

```{r layout='l-body-outset'}
item_order_bias %>% 
  show_dt()
```

```{r layout='l-body-outset'}
item_order_bias %>% 
  filter(term == "display_order") %>% 
  ggplot(aes(x = response, y = estimate, ymin = conf.low, ymax = conf.high)) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  geom_pointrange() +
  coord_flip()
```

### All randomised exposures
We have three randomised variables:

- display order
- number of items shown
- the times the item was seen already (reference category: first day)
- last item

We adjust for day number (0 to 7+), the time period referred to (confounded with how often people have responded so far), random effects for the participant

```{r fig.width=10,fig.height=8}
predictors <- first_page %>% 
  mutate(item_order = factor(display_order),
         times_item_shown = times_item_answered_factor,
         items_shown = factor(number_of_items_shown),
         last_item = relevel(factor(last_item), "none"),
         dnr = day_number,
         day_number = day_number_factor
         )

complex_mods <-  predictors %>% 
  split(.$item_name) %>%
  map(~ lmer(answer ~ items_shown + item_order + times_item_shown + day_number + refer_time_period +  (1 | session), data = .))


all_biases <- complex_mods %>% 
  map(~ tidy(., conf.int = TRUE, conf.level = 0.99)) %>% 
  bind_rows(.id = "response") 


all_biases %>% 
  filter(term != "refer_time_periodlast entry", 
         str_sub(term, 1, 10) != "day_number", term != "(Intercept)", !is.na(conf.high)) %>% 
  ggplot(aes(x = term, y = estimate, ymin = conf.low, ymax = conf.high)) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  facet_wrap(~ response) +
  geom_pointrange() +
  coord_flip()
```

Is there evidence for an additional bias of the last item identity? We test this separately because item order 1 and last item "none" are identical, and estimates become less precise because of similar, less severe multicollinearity.

```{r}
predictors %>% 
  split(.$item_name) %>%
  map(~ as.data.frame(anova(
    lmer(answer ~ items_shown + item_order + times_item_shown + day_number + refer_time_period +  (1 | session), data = ., REML = FALSE),
    lmer(answer ~ last_item + items_shown + item_order + times_item_shown + day_number + refer_time_period +  (1 | session), data = .), REML = FALSE)
    )) %>% 
  bind_rows(.id = "response") %>% 
  knitr::kable()
```


How much do our variables change when we residualise for all of these biases?

```{R}
predictors %>% 
  split(.$item_name) %>%
  map(~ cor(.$answer, residuals(lm(answer ~ items_shown + last_item + times_item_shown + day_number + refer_time_period, data = .)))) %>% 
  bind_rows() %>% 
  gather(variable, cor) %>% 
  arrange(cor) %>% 
  knitr::kable()
```

Not much at all.

<details><summary>Allow individual differences in biases</summary>

Here, we additionally residualise the item response for inter-individual person-level intercepts and then see whether further residualising for the average biases and person-level varying biases makes a large difference. It does not. In this model, only display order, number of items shown, and times item answered are adjusted for continuously, or the number of random effects would exceed the number of rows.

```{r}
predictors %>% 
  split(.$item_name) %>%
  map(~ cor(residuals(lmer(answer ~ (1 | session), .)), fitted(lmer(answer ~ scale(display_order) + scale(number_of_items_shown) + scale(times_item_answered) + (1 + scale(display_order) + scale(number_of_items_shown) + scale(times_item_answered) | session), data = .)))^2) %>% 
  bind_rows() %>% 
  gather(variable, cor) %>% 
  arrange(cor) %>% 
  knitr::kable()

```

</details>


#### Regression table
```{r layout='l-body-outset'}
all_biases %>% 
  show_dt()
```

### Continuous predictors
```{r}
predictors <- first_page %>% 
  mutate(item_order = display_order,
         times_item_shown = times_item_answered,
         items_shown = number_of_items_shown
         )
complex_mods <-  predictors %>% 
  split(.$item_name) %>%
  map(~ lmer(answer ~ items_shown + item_order + times_item_shown + day_number + refer_time_period +  (1 | session), data = .))


all_biases <- complex_mods %>% 
  map(~ tidy(., conf.int = TRUE, conf.level = 0.99)) %>% 
  bind_rows(.id = "response") 


all_biases %>% 
  filter(is.na(group)) %>% 
  filter(term != "(Intercept)") %>% 
  left_join(
    first_page %>% select(response = item_name, item = label_english, item_mean, item_sd) %>% distinct()
  ) %>% 
  mutate(term = fct_recode(term, 
                           "No. times item shown" = "times_item_shown",
                           "Ref: since last entry" = "refer_time_periodlast entry",
                           "No. items shown" = "items_shown",
                           "Item order" = "item_order",
                           "Day number" = "day_number")) %>% 
  # filter(term != "refer_time_periodlast entry", 
         # str_sub(term, 1, 10) != "day_number", term != "(Intercept)", !is.na(conf.high)) %>% 
  ggplot(aes(x = term, y = estimate, ymin = conf.low, ymax = conf.high)) +
  geom_rect(ymin = -0.1, ymax = 0.1, xmin = -Inf, xmax = Inf, fill = "lightblue") +
  # geom_blank(aes(y = estimate, ymin = estimate - item_sd, ymax = estimate + item_sd)) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  facet_wrap(~ item) +
  geom_pointrange() +
  coord_flip()
```


### Continuous predictors, adjusted for weekday
```{r fig.width=12, fig.height=6}
predictors <- first_page %>% 
  mutate(item_order = display_order,
         times_item_shown = times_item_answered,
         items_shown = number_of_items_shown
         )
library(lme4)
library(lmerTest)
library(broom.mixed)
complex_mods <-  predictors %>% 
  split(.$item_name) %>%
  map(~ lmer(answer ~ items_shown + item_order + times_item_shown + poly(scale(day_number, scale=F)/10, degree = 3, raw = T) + refer_time_period +  (1 | session), data = .))

complex_mods <-  predictors %>% 
  split(.$item_name) %>%
  map(~ lmer(answer ~ weekday + items_shown + item_order + times_item_shown + poly(scale(day_number, scale=F)/10, degree = 3, raw = T) + refer_time_period +  (1 | session), data = .))

all_biases <- complex_mods %>% 
  map(~ tidy(., conf.int = TRUE, conf.level = 0.99)) %>% 
  bind_rows(.id = "response") 


all_biases %>% 
  filter(is.na(group)) %>% 
  filter(term != "(Intercept)") %>% 
  left_join(
    first_page %>% select(response = item_name, item = label_english, item_mean, item_sd) %>% distinct()
  ) %>% 
  mutate(term = fct_relevel(fct_recode(term, 
                           "R. No. times item shown" = "times_item_shown",
                           "Ref: since last entry" = "refer_time_periodlast entry",
                           "R. No. items shown" = "items_shown",
                           "R. Item order" = "item_order",
                           "Day" = "poly(scale(day_number, scale = F)/10, degree = 3, raw = T)1",
                           "Day^2" = "poly(scale(day_number, scale = F)/10, degree = 3, raw = T)2",
                           "Day^3" = "poly(scale(day_number, scale = F)/10, degree = 3, raw = T)3"),
                           "R. No. items shown", 
                           "R. No. times item shown", 
                           "R. Item order",
                           "Ref: since last entry",
                           "Day^3",
                           "Day^2",
                           "Day")
                           ) %>% 
  # filter(term != "refer_time_periodlast entry", 
         # str_sub(term, 1, 10) != "day_number", term != "(Intercept)", !is.na(conf.high)) %>% 
  ggplot(aes(x = term, y = estimate, ymin = conf.low, ymax = conf.high)) +
  geom_rect(ymin = -0.1, ymax = 0.1, xmin = -Inf, xmax = Inf, fill = "lightblue", alpha = 0.5) +
  # geom_blank(aes(y = estimate, ymin = estimate - item_sd, ymax = estimate + item_sd)) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  ggrepel::geom_text_repel(aes(label = sprintf("%.2f",estimate)), force = 0, nudge_x = 0.35, segment.size = 0) +
  facet_wrap(~ item) +
  geom_pointrange() +
  coord_flip()

ggsave(width = 12, height = 6, filename = "Figure6.png")
```

How much do our variables change when we residualise for all of these biases?

```{R}
predictors %>% 
  split(.$item_name) %>%
  map(~ cor(.$answer, residuals(lm(answer ~ items_shown + last_item + times_item_shown + day_number + refer_time_period, data = .)))) %>% 
  bind_rows() %>% 
  gather(variable, cor) %>% 
  arrange(cor) %>% 
  knitr::kable()
```

#### Regression table
```{r layout='l-body-outset'}
all_biases %>% 
  show_dt()
```


### Regression table
```{r layout='l-body-outset'}
initial_elevation_bias_rt %>% 
  show_dt()
```


## Other items

We focused on the most general items on the first page of our study.
However, the diary also contained randomised (in order and odds of appearing) items about sexual desire, time use, and partner jealousy, among others. We show that
the overall results (that residualising for estimated biases has negligible effects) holds here too, even though the partner jealousy items were asked on a response scale from "not at all" to "very much", the desire items on a scale of "very inaccurate" to "very accurate", and the time use items on the same "less than usual" to "more than usual" scale as the items on the first page.

### Time items
```{r}
time_items = s3_daily_id_answered  %>% 
  filter(item_name %starts_with% "time_") %>% 
  group_by(session, unit_session_id) %>% 
  mutate(display_order = min_rank(display_order),
         number_of_items_shown = n()) %>%  
  arrange(session, unit_session_id, display_order) %>% 
  mutate(
        last_item = if_na(lag(label_english), "[None]")) %>% 
  ungroup() %>% 
  mutate(last_item = relevel(factor(last_item), ref =  "[None]"))
```

On  a "less than usual" to "more than usual" response scale.



```{r}
time_items %>% group_by(item_name, label_english) %>% 
  summarise(women = n_distinct(session),
            days = n_distinct(unit_session_id)) %>% 
  knitr::kable()
```

```{r}
time_items %>% 
  filter(day_number < 7) %>% 
  group_by(item_name) %>% 
  mutate(group_mean = mean(answer, na.rm = TRUE)) %>% 
  group_by(item_name, day_number, first_day_of_item_factor) %>% 
  filter(n_nonmissing(answer) > 20) %>% 
  ggplot(., aes(day_number, answer, colour = first_day_of_item_factor)) + 
  geom_blank(aes(y = item_mean, ymin = item_mean - item_sd, ymax = item_mean + item_sd)) +
  geom_hline(aes(yintercept = group_mean, group = label), color = "gray", linetype = 'dashed') +
  geom_pointrange(position = position_dodge(width = 0.2), stat = 'summary', fun.data = 'mean_se') + 
  geom_line(position = position_dodge(width = 0.4), stat = 'summary', fun.data = 'mean_se') + 
  scale_color_colorblind("First day the\nitem was shown") +
  scale_y_continuous("Response") +
  facet_wrap(~ label_english, scales = "free_y", nrow = 3) + 
  scale_x_continuous("Day number", breaks = 0:10)
```


```{r fig.width=10,fig.height=8}
predictors <- time_items %>% 
  mutate(
    item_order = factor(display_order),
     times_item_shown = times_item_answered_factor,
     items_shown = factor(number_of_items_shown),
     last_item = relevel(factor(last_item), "none"),
     dnr = day_number,
     day_number = day_number_factor
     )

complex_mods <-  predictors %>% 
  split(.$item_name) %>%
  map(~ lmer(answer ~ items_shown + item_order + times_item_shown + day_number + refer_time_period +  (1 | session), data = .))


all_biases <- complex_mods %>% 
  map(~ tidy(., conf.int = TRUE, conf.level = 0.99)) %>% 
  bind_rows(.id = "response") 


all_biases %>% 
  filter(term != "refer_time_periodlast entry", 
         str_sub(term, 1, 10) != "day_number", term != "(Intercept)", !is.na(conf.high)) %>% 
  ggplot(aes(x = term, y = estimate, ymin = conf.low, ymax = conf.high)) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  facet_wrap(~ response) +
  geom_linerange() +
  scale_y_continuous("99% CIs for regression coefficients") +
  coord_flip()
```


How much do our variables change when we residualise for all of these biases?

```{R}
predictors %>% 
  split(.$item_name) %>%
  map(~ cor(.$answer, residuals(lm(answer ~ items_shown + last_item + times_item_shown + day_number + refer_time_period, data = .)))) %>% 
  bind_rows() %>% 
  gather(variable, cor) %>% 
  arrange(cor) %>% 
  knitr::kable()
```

### Desire items

```{r}
desire_items = s3_daily_id_answered  %>% 
  filter(item_name %in% c("in_pair_desire_7", "in_pair_desire_8",
                     "in_pair_desire_10", "in_pair_desire_11",
                     "in_pair_desire_13", "in_pair_desire_14")) %>% 
  group_by(session, unit_session_id) %>% 
  mutate(display_order = min_rank(display_order),
         number_of_items_shown = n()) %>%  
  arrange(session, unit_session_id, display_order) %>% 
  mutate(
        last_item = if_na(lag(label_english), "[None]")) %>% 
  ungroup() %>% 
  mutate(last_item = relevel(factor(last_item), ref =  "[None]"))
```


On a "very inaccurate" to "very accurate" response scale.

```{r}
desire_items %>% 
  filter(day_number < 7) %>% 
  group_by(item_name) %>% 
  mutate(group_mean = mean(answer, na.rm = TRUE)) %>% 
  group_by(item_name, day_number, first_day_of_item_factor) %>% 
  filter(n_nonmissing(answer) > 20) %>% 
  ggplot(., aes(day_number, answer, colour = first_day_of_item_factor)) + 
  geom_blank(aes(y = item_mean, ymin = item_mean - item_sd, ymax = item_mean + item_sd)) +
  geom_hline(aes(yintercept = group_mean, group = label), color = "gray", linetype = 'dashed') +
  geom_pointrange(position = position_dodge(width = 0.2), stat = 'summary', fun.data = 'mean_se') + 
  geom_line(position = position_dodge(width = 0.4), stat = 'summary', fun.data = 'mean_se') + 
  scale_color_colorblind("First day the\nitem was shown") +
  scale_y_continuous("Response") +
  facet_wrap(~ label_english, scales = "free_y", nrow = 3) + 
  scale_x_continuous("Day number", breaks = 0:10)
```

```{r}
desire_items %>% group_by(label_english) %>% 
  summarise(women = n_distinct(session),
            days = n_distinct(unit_session_id)) %>% 
  knitr::kable()
```


```{r fig.width=10,fig.height=8}
predictors <- desire_items %>% 
  mutate(item_order = factor(display_order),
         times_item_shown = times_item_answered_factor,
         items_shown = factor(number_of_items_shown),
         last_item = relevel(factor(last_item), "none"),
         dnr = day_number,
         day_number = day_number_factor
         )

complex_mods <-  predictors %>% 
  split(.$item_name) %>%
  map(~ lmer(answer ~ items_shown + item_order + times_item_shown + day_number + refer_time_period +  (1 | session), data = .))


all_biases <- complex_mods %>% 
  map(~ tidy(., conf.int = TRUE, conf.level = 0.99)) %>% 
  bind_rows(.id = "response") 


all_biases %>% 
  filter(term != "refer_time_periodlast entry", 
         str_sub(term, 1, 10) != "day_number", term != "(Intercept)", !is.na(conf.high)) %>% 
  ggplot(aes(x = term, y = estimate, ymin = conf.low, ymax = conf.high)) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  facet_wrap(~ response) +
  geom_linerange() +
  scale_y_continuous("95% CIs for regression coefficients") +
  coord_flip()
```

How much do our variables change when we residualise for all of these biases?

```{R}
predictors %>% 
  split(.$item_name) %>%
  map(~ cor(.$answer, residuals(lm(answer ~ items_shown + last_item + times_item_shown + day_number + refer_time_period, data = .)))) %>% 
  bind_rows() %>% 
  gather(item, cor) %>% 
  arrange(cor) %>% 
  knitr::kable()
```

### Retention items
```{r}
retention_items = s3_daily_id_answered  %>% 
  filter(item_name %contains% "mate_retention") %>% 
  group_by(session, unit_session_id) %>% 
  mutate(display_order = min_rank(display_order),
         number_of_items_shown = n()) %>%  
  arrange(session, unit_session_id, display_order) %>% 
  mutate(
        last_item = if_na(lag(label_english), "[None]")) %>% 
  ungroup() %>% 
  mutate(last_item = relevel(factor(last_item), ref =  "[None]"))
```

On a "not at all" to "very much" response scale.

```{r}
retention_items %>% 
  filter(day_number < 7) %>% 
  group_by(item_name) %>% 
  mutate(group_mean = mean(answer, na.rm = TRUE)) %>% 
  group_by(item_name, day_number, first_day_of_item_factor) %>% 
  filter(n_nonmissing(answer) > 20) %>% 
  ggplot(., aes(day_number, answer, colour = first_day_of_item_factor)) + 
  geom_blank(aes(y = item_mean, ymin = item_mean - item_sd, ymax = item_mean + item_sd)) +
  geom_hline(aes(yintercept = group_mean, group = label), color = "gray", linetype = 'dashed') +
  geom_pointrange(position = position_dodge(width = 0.2), stat = 'summary', fun.data = 'mean_se') + 
  geom_line(position = position_dodge(width = 0.4), stat = 'summary', fun.data = 'mean_se') + 
  scale_color_colorblind("First day the\nitem was shown") +
  scale_y_continuous("Response") +
  facet_wrap(~ label_english, scales = "free_y", nrow = 3) + 
  scale_x_continuous("Day number", breaks = 0:10)
```

```{r}
retention_items %>% 
  group_by(item_name, label_english) %>% 
  summarise(women = n_distinct(session),
            days = n_distinct(unit_session_id)) %>% 
  knitr::kable()
```




```{r fig.width=10,fig.height=8}
predictors <- retention_items %>% 
  mutate(
    item_order = factor(display_order),
    times_item_shown = times_item_answered_factor,
    items_shown = factor(number_of_items_shown),
    last_item = relevel(factor(last_item), "none"),
    dnr = day_number,
    day_number = day_number_factor
  )

complex_mods <-  predictors %>% 
  split(.$item_name) %>%
  map(~ lmer(answer ~ items_shown + item_order + times_item_shown + day_number + refer_time_period +  (1 | session), data = .))


all_biases <- complex_mods %>% 
  map(~ tidy(., conf.int = TRUE, conf.level = 0.99)) %>% 
  bind_rows(.id = "response")


all_biases %>% 
  filter(term != "refer_time_periodlast entry", 
         str_sub(term, 1, 10) != "day_number", term != "(Intercept)", !is.na(conf.high)) %>% 
  ggplot(aes(x = term, y = estimate, ymin = conf.low, ymax = conf.high)) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  facet_wrap(~ response) +
  scale_y_continuous("95% CIs for regression coefficients") +
  geom_linerange() +
  coord_flip()
```

How much do our variables change when we residualise for all of these biases?

```{R}
predictors %>% 
  split(.$item_name) %>%
  map(~ cor(.$answer, residuals(lm(answer ~ items_shown + last_item + times_item_shown + day_number + refer_time_period, data = .)))) %>% 
  bind_rows() %>% 
  gather(item, cor) %>% 
  arrange(cor) %>% 
  knitr::kable()
```


## Dropout

The additional workload on each day (total number of randomised items that were shown)
is a random variable, conditional on relationship status (women in relationships had
to answer slightly more questions, some of which were also randomised in appearance). 
We can use this variable to predict whether a woman who had to answer more questions
is less likely to answer the diary on the next day.

```{r}
crosstabs(~ did_not_finish_entry + skipped_day, diary)

ggplot(diary, aes(nr_items_day_done, fill = factor(hetero_relationship))) + 
  geom_bar() +
  scale_fill_colorblind(guide = FALSE) +
  facet_wrap(~ hetero_relationship, labeller = as_labeller(c("0" = "single", "1" = "in relationship")))


ggplot(diary %>% group_by(hetero_relationship, lag_nr_items_day) %>% 
         summarise(count = n(),
                   skip = mean(skipped_day, na.rm = T)), aes(lag_nr_items_day, count, fill = skip)) + 
  geom_bar(stat = 'identity') +
  scale_color_viridis_c() +
  facet_wrap(~ hetero_relationship, labeller = as_labeller(c("0" = "single", "1" = "in relationship")))

ggplot(diary, aes(lag_nr_items_day, skipped_day, color = factor(hetero_relationship))) + 
  geom_pointrange(stat='summary', fun.data='mean_cl_boot', alpha = 0.5) +
  geom_smooth(method = 'glm', method.args = list(family = binomial())) +
  scale_color_colorblind(guide = F) +
  facet_wrap(~ hetero_relationship, labeller = as_labeller(c("0" = "single", "1" = "in relationship")))

library(Hmisc)
ggplot(diary %>% 
         group_by(hetero_relationship, lag_nr_items_day) %>% 
         filter(n() > 100), aes(lag_nr_items_day, skipped_day, color = factor(hetero_relationship))) + 
  geom_pointrange(stat='summary', fun.data='mean_cl_boot', alpha = 0.5) +
  geom_smooth(method = 'glm', method.args = list(family = binomial())) +
  scale_color_colorblind(guide = F) +
  facet_wrap(~ hetero_relationship, labeller = as_labeller(c("0" = "single", "1" = "in relationship")))

summary(m1 <- lme4::glmer(skipped_day ~ lag_nr_items_day * hetero_relationship + (1 + lag_nr_items_day | session), diary %>% ungroup() %>% 
                      mutate(lag_nr_items_day = lag_nr_items_day/10), family = binomial))

library(effects)
plot(allEffects(m1))
coef(m1)$session %>% as_tibble(rownames = "session") %>% 
  left_join(diary %>% select(session, hetero_relationship) %>% distinct(), by = 'session', suffix = c("_est", "")) %>% 
  arrange(lag_nr_items_day) %>% 
  mutate(woman = fct_inorder(session)) %>% 
ggplot(aes(woman, lag_nr_items_day, color = factor(hetero_relationship))) +
  geom_point() +
  coord_flip()  +
  scale_color_colorblind(guide = F) +
  facet_wrap(~ hetero_relationship, labeller = as_labeller(c("0" = "single", "1" = "in relationship")))
  

summary(glm(skipped_day ~ lag_nr_items_day, diary %>% ungroup() %>% filter(between(lag_nr_items_day, 10,37)), family = binomial))
```
